# guardian/src/guardian/daemon_logic.py
import os
import typer
from pathlib import Path
from guardian.utils import run_alembic_command, validate_migration_safety
import git # New import for GitPython
from guardian.brain import GuardianBrain

# Initialize the Brain
brain = GuardianBrain()

def _handle_git_workflow(migration_file_abs_path: Path, repo_root: Path):
    """
    Handles Git operations for a newly generated migration.
    """
    typer.echo(f"Git workflow: Processing migration file {migration_file_abs_path} in repository {repo_root}...")
    
    # --- Brain & Static Review ---
    typer.echo("Guardian: Performing safety validation...")
    try:
        with open(migration_file_abs_path, 'r') as f:
            migration_code = f.read()
        
        static_warnings = validate_migration_safety(migration_code)
        brain_review = brain.review_migration(migration_code)
        
        full_review = "--- Static Safety Check ---\n"
        if static_warnings:
            full_review += "\n".join([f"⚠️ {w}" for w in static_warnings])
        else:
            full_review += "✅ No destructive operations detected by static analysis."
            
        full_review += f"\n\n--- AI Brain Review ---\n{brain_review}"
        
        typer.echo(full_review)
    except Exception as e:
        typer.echo(f"Safety validation failed: {e}")
        full_review = "Validation failed."

    try:
        repo = git.Repo(repo_root) # Initialize repo with the correct root
    except git.InvalidGitRepositoryError:
        typer.echo(f"Error: Directory {repo_root} is not a Git repository. Skipping Git workflow.")
        return

    # Check if repo is dirty (uncommitted changes) - optional, for robustness
    if repo.is_dirty(untracked_files=True):
        typer.echo("Warning: Git repository has uncommitted changes or untracked files. Please commit or stash them before generating migrations.")
        # Decide whether to proceed or abort. For now, we proceed.

    # Get path of migration file relative to repo root
    migration_file_repo_rel_path = migration_file_abs_path.relative_to(repo_root)

    # Check if a branch already exists for this migration
    branch_name = f"guardian-migration/{migration_file_abs_path.stem}"
    
    current_branch = repo.active_branch.name # Store current branch

    if branch_name in repo.heads:
        typer.echo(f"Branch '{branch_name}' already exists. Checking out.")
        repo.heads[branch_name].checkout()
    else:
        typer.echo(f"Creating new branch '{branch_name}' from '{current_branch}'.")
        new_branch = repo.create_head(branch_name)
        new_branch.checkout()

    # Add the migration file
    typer.echo(f"Adding {migration_file_repo_rel_path} to Git.")
    repo.index.add([str(migration_file_repo_rel_path)])

    # Commit the changes
    commit_message = f"feat(migration): {migration_file_abs_path.stem}\n\nGuardian Safety Review:\n{full_review}"
    typer.echo(f"Committing changes with message: '{commit_message}'")
    repo.index.commit(commit_message)

    typer.echo("Git workflow complete (branch, add, commit).")
    typer.echo(f"You are now on branch '{branch_name}'.")
    typer.echo("Please review the migration and consider pushing the branch and creating a Pull Request.")
    
    # Switch back to original branch
    typer.echo(f"Switching back to original branch '{current_branch}'.")
    repo.heads[current_branch].checkout()


def generate_migration(file_path: Path):
    """
    Generates an autogenerated migration based on changes in the model file.
    """
    typer.echo(f"Daemon: Model file modified: {file_path}. Attempting to generate migration...")
    
    # Run alembic revision command
    alembic_output = run_alembic_command(["revision", "--autogenerate", "-m", f"Auto-migration for {file_path.name}"], cwd=file_path.parent)

    typer.echo("Daemon: Migration generation command executed.")

    # Parse alembic output to find the new migration file
    new_migration_file_abs_path = None
    for line in alembic_output.splitlines():
        # Look for the line that contains the full path to the generated file
        if "migrations/versions/" in line and ".py" in line:
            # Extract the full path which is typically after "Generating" and before " ... done"
            try:
                start_marker = "Generating "
                end_marker = " ... done"
                start_index = line.find(start_marker)
                end_index = line.find(end_marker)

                if start_index != -1 and end_index != -1:
                    full_path_str = line[start_index + len(start_marker):end_index].strip()
                    new_migration_file_abs_path = Path(full_path_str)
                    break
            except Exception as e:
                typer.echo(f"Error parsing migration file path from line: {line}. Error: {e}")
                
    # Pass the repository root (which is test_project in this test) to the Git handler
    if new_migration_file_abs_path:
        typer.echo(f"Daemon: New migration file detected: {new_migration_file_abs_path}")
        _handle_git_workflow(new_migration_file_abs_path, repo_root=Path(os.getcwd()) / file_path.parent) # Corrected repo_root
    else:
        typer.echo("Daemon: Could not find newly generated migration file in alembic output.")